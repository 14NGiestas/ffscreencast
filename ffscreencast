#!/usr/bin/env bash
#
# @Author:  Patrick Plocke <patrick@plocke.de>
# @GPG      0x28BF179F
# @Licence: MIT
#
# @Description:
# ffscreencast is a shell wrapper for ffmpeg that allows fool-proof screen
# recording via the command line. It will auto-detect all available monitors,
# cameras and microphones and is able to interactively or manually choose the
# desired recording device(s). Additionally ffscreencast will let you overlay
# the camera stream on top of the desktop session.
#
# Besides that ffscreencast can act as an ffmpeg command generator. Every
# available option can also just show the corresponding ffmpeg command instead
# of executing it.

INFO_AUTHOR="Patrick Plocke <patrick@plocke.de>"
INFO_GPGKEY="0x28BF179F"
INFO_DATE="2015-12-09"
INFO_LICENSE="MIT"
INFO_VERSION="0.5"



################################################################################
# File name and path
################################################################################

# Name of the output file
DATE=$(date +%Y-%m-%d)
TIME=$(date +%H.%M.%S)
NAME="Screencast ${DATE} at ${TIME}"

# Where to save it
DIR="${HOME}/Desktop"


################################################################################
# Binaries
################################################################################
GREP="$(which grep 2>/dev/null)"
AWK="$(which awk 2>/dev/null)"
SED="$(which sed 2>/dev/null)"



################################################################################
# FFmpeg Options
################################################################################

# Get current resolution
#RESO=$(system_profiler SPDisplaysDataType | grep Resolution)
#WIDTH=$(echo $RESO | awk '{print $2}')
#HEIGHT=$(echo $RESO | awk '{print $4}')

# -qp 0 tells x264 to encode in lossless mode,
# -preset ultrafast advises it to do so fast.
#LOSSLESS="-qp 0"
#LOSSLESS=""
#PRESET="ultrafast"
#PIXFMT="uyvy422"
#OPTIONS="-framerate ${FF_FRAME_RATE} "
# ffmpeg -f avfoundation -i 1 -c:v libx264rgb -crf 0 -preset:v ultrafast -c:a pcm_s16le -af aresample=async=1:first_pts=0 out.mkv




################################################################################
# Helper Functions
################################################################################

#
# Test if argument is an integer
#
# @param	mixed		Input value
# @return	integer		Return code (0: OK | 1: ERR)
isint() {
	printf '%d' "$1" >/dev/null 2>&1 && return 0 || return 1;
}



################################################################################
# About Function
################################################################################

#
# Display program usage
#
usage() {
	printf "%s %s %s\n" "Usage:" "${0}" "[-s[num]] [--sargs=] [-a[num]] [--aargs=] [-c[num] [--cargs=] [--oargs=] [-e<ext>] [--dry]"
	printf "%s %s %s\n" "      " "${0}" "--slist [--dry]"
	printf "%s %s %s\n" "      " "${0}" "--alist [--dry]"
	printf "%s %s %s\n" "      " "${0}" "--clist [--dry]"
	printf "%s %s %s\n" "      " "${0}" "--help"
	printf "%s %s %s\n" "      " "${0}" "--version"
	printf "%s %s %s\n" "      " "${0}" "--test"
	echo
	echo "When invoked without any arguments, it will start screen recording"
	echo "on the default screen without sound and without camera overlay."
	echo
	echo "Input options:"
	echo "-s[num]           (Default) Enable screen capturing [with device number X]."
	echo "                  If no device number is specified it will use the default, if only"
	echo "                  one device is present, otherwise it will ask you to choose one"
	echo "                  Use: -s or -s1"
	echo
	echo "--sargs=          Additional screen arguments."
	echo "                  Specify additional ffmpeg arguments for the screen input device."
	echo "                  Use: --sargs=\"-framerate 30\""
	echo "                  Default: ''"
	echo
	echo "-a[num]           Enable audio capturing [with device number X]"
	echo "                  If no device number is specified it will use the default, if only"
	echo "                  one device is present, otherwise it will ask you to choose one"
	echo "                  Use: -a or -a1"
	echo
	echo "--aargs=          Additional audio arguments."
	echo "                  Specify additional ffmpeg arguments for the audio input device."
	echo "                  Use: --aargs=\"-ac 1\""
	echo "                  Default: '-ac 2'"
	echo
	echo "-c[num]           Add camera overlay [with device number X]"
	echo "                  If no device number is specified it will use the default, if only"
	echo "                  one device is present, otherwise it will ask you to choose one"
	echo "                  Use: -c or -c1"
	echo
	echo "--cargs=          Additional camera arguments"
	echo "                  Specify additional ffmpeg arguments for the camera input device."
	echo "                  Use: --cargs=\"-video_size 1280x720\""
	echo "                  Default: ''"
	echo
	echo
	echo "Output options:"
	echo "-e<ext>           Output video format extension (Default: mkv)"
	echo "                  E.g.: -emkv, or -eavi, or -emp4"
	echo
	echo "-oargs=           Additional output arguments"
	echo "                  Specify additional ffmpeg arguments for the output encoding."
	echo "                  Use: --oargs=\"-crf 0\""
	echo "                  Default: '-crf 0 -preset ultrafast'"
	echo
	echo
	echo "Behavior options:"
	echo "--dry             Show the command (without executing)"
	echo
	echo
	echo "List options:"
	echo "--list            List all devices"
	echo "--slist           Only list screen capturing devices (monitors)"
	echo "--alist           Only list audio capturing devices (microphones)"
	echo "--clist           Only list camera capturing devices (cams)"
	echo
	echo
	echo "System information:"
	echo "--help            Show this help screen"
	echo "--version         Show version information"
	echo "--test            Test requirements"
}

#
# Display program version and credits
#
version() {
	printf "Version: %s (%s)\n" "${INFO_VERSION}" "${INFO_DATE}"
	printf "Author:  %s (%s)\n" "${INFO_AUTHOR}" "${INFO_GPGKEY}"
	printf "License: %s\n" "${INFO_LICENSE}"
}

#
# Check program requirements
#
# @param	string		"verbose"
# @return	integer		Return code (0: OK | 1: ERR)
check_requirements() {
	uname="$(uname)"

	#### 1.) Check Operating System
	if [ "${uname}" != "Linux"  ] && [ "${uname}" != 'Darwin'  ]; then
		echo "Unsupported operating system."
		echo "It currently only works on Linux and OSX."
		echo "Sorry ;-)"
		return 1
	elif [ "${1}" = "verbose" ]; then
		echo "[OK] Operating system supported: ${uname}"
	fi

	#### 2.) Check ffmpeg
	if ! command -v ffmpeg > /dev/null 2>&1; then
		echo "ffmpeg not found."
		return 1
	elif [ "${1}" = "verbose" ]; then
		echo "[OK] ffmpeg found: $(which ffmpeg)"
	fi

	#### 3.) Check OSX
	if [ "${uname}" = "Darwin" ]; then
		if ! ffmpeg -f avfoundation -list_devices true -i "" 2>&1 | $GREP 'AVFoundation input device' > /dev/null 2>&1; then
			echo "OSX: AVFoundation not available in ffmpeg"
			return 1
		elif [ "${1}" = "verbose" ]; then
			echo "[OK] OSX: AVFoundation available in ffmpeg"
		fi
	fi

	#### 4.) Check Linux
	if [ "${uname}" = "Linux" ]; then
		if ! ffmpeg 2>&1 | $GREP '\-\-enable-x11grab' > /dev/null 2>&1; then
			echo "Linux: x11grab not available in ffmpeg"
			return 1
		elif [ "${1}" = "verbose" ]; then
			echo "[OK] Linux: x11grab available in ffmpeg"
		fi

		if ! command -v v4l2-ctl > /dev/null 2>&1; then
			echo "Linux: v4l2-ctl not found."
			echo
			echo "Debian: apt-get install v4l-utils"
			echo "CentOS: yum install v4l-utils"
			echo "Arch:   pacman -S v4l-utils"
			return 1
		elif [ "${1}" = "verbose" ]; then
			echo "[OK] Linux: v4l2-ctl found: $(which v4l2-ctl)"
		fi

		if ! command -v arecord > /dev/null 2>&1; then
			echo "Linux: arecord not found."
			echo
			echo "Debian: apt-get install alsa-utils"
			echo "CentOS: yum install alsa-utils"
			echo "Arch:   pacman -S alsa-utils"
			return 1
		elif [ "${1}" = "verbose" ]; then
			echo "[OK] Linux: arecord found: $(which arecord)"
		fi

		if ! command -v xdpyinfo > /dev/null 2>&1; then
			echo "Linux: xdpyinfo not found."
			echo
			echo "Debian: apt-get install x11-utils"
			echo "CentOS: yum install xorg-x11-utils"
			echo "Arch:   pacman -S xorg-xdpyinfo"
			return 1
		elif [ "${1}" = "verbose" ]; then
			echo "[OK] Linux: xdpyinfo found: $(which xdpyinfo)"
		fi
	fi

	return 0
}



################################################################################
# Get OS dependent device names
################################################################################

#
# Get list of screen devices (monitors)
#
# @param	string		"dry": Show command only
get_screen_device_names() {
	if [ "$(uname)" = "Darwin" ]; then
		DEVICE_NAMES="paste <(echo \"\$(ffmpeg -f avfoundation -list_devices true -i '' 2>&1 | $GREP 'AVFoundation input' | $SED -n '/AVFoundation video/,/AVFoundation audio/p' | $GREP -oE '\[[0-9]\].*$' | $GREP 'Capture screen')\") <(echo \"\$(system_profiler SPDisplaysDataType | $SED -n '/^\s.*Displays:$/,\$p' | $GREP -vE '^\s.*Displays:$' | $GREP -E '^\s.*w*:$|Resolution:' | $SED 'N;s/\n/ /' | $SED 's/ \{1,\}/ /g' | $SED 's/^[ \t ]*//;s/[ \t ]*$//')\")"
	elif [ "$(uname)" = "Linux" ]; then
		DEVICE_NAMES="xdpyinfo | $GREP -A 1 -E '^screen #[0-9]*:' | $GREP -vE '^\-\-' | $SED 'N;s/\n/ /' | $SED 's/dimensions://g' | $SED 's/ \{1,\}/ /g' | $AWK '{printf \"[%d] %s\n\", NR, \$0}'"
	fi
	if [ "${1}" = "yes" ]; then echo "${DEVICE_NAMES}"; else eval "${DEVICE_NAMES}"; fi
}

#
# Get list of audio devices (microphones)
#
# @param	string		"dry": Show command only
get_audio_device_names() {
	if [ "$(uname)" = "Darwin" ]; then
		DEVICE_NAMES="ffmpeg -f avfoundation -list_devices true -i '' 2>&1 | $GREP 'AVFoundation input' | $SED -n '/AVFoundation audio/,\$p' | $GREP -oE '\[[0-9]\].*$'"
	elif [ "$(uname)" = "Linux" ]; then
		DEVICE_NAMES="arecord -l | $GREP -E '^card\s[0-9]*:' | $AWK '{printf \"[%d] %s\n\", NR, \$0}'"
	fi
	if [ "${1}" = "yes" ]; then echo "${DEVICE_NAMES}"; else eval "${DEVICE_NAMES}"; fi
}

#
# Get list of camera devices
#
# @param	string		"dry": Show command only
get_camera_device_names() {
	if [ "$(uname)" = "Darwin" ]; then
		DEVICE_NAMES="ffmpeg -f avfoundation -list_devices true -i '' 2>&1 | $GREP 'AVFoundation input' | $SED -n '/AVFoundation video/,/AVFoundation audio/p' | $GREP -oE '\[[0-9]\].*$' | $GREP 'Camera' | while read line; do tmp=\"\$(echo \$line | $GREP -oE '^\[[0-9]*\]' | $SED 's/\[//' | $SED 's/\]//')\"; reso=\"\$(ffmpeg -t 1 -f avfoundation -r 0.1 -i \$tmp -f mkv - 2>&1 | $GREP '\[avfoundation' | $SED -n '/Supported modes:/,\$p' | $GREP -oE '[0-9]*x[0-9]*\@\[.*fps' | $SED 's/\[[0-9]*\.[0-9]*//' | $SED 's/\s//' | $SED 's/]fps//' | $AWK '{ if(\$0 ~ /\./) sub(\"\\\.*0+\$\",\"\");print}' | tr '\n' ' ' | xargs)\"; echo \"\$line (\$reso)\"; done"
	elif [ "$(uname)" = "Linux" ]; then
		DEVICE_NAMES="v4l2-ctl --list-devices | $GREP -B 1 '/dev/video' | $GREP -vE '^\-\-' | $SED 'N;s/\n/ /' | $SED 's/ \{1,\}/ /g' | $AWK '{printf \"[%d] %s\n\", NR, \$0}'"
	fi
	if [ "${1}" = "yes" ]; then echo "${DEVICE_NAMES}"; else eval "${DEVICE_NAMES}"; fi
}



################################################################################
# Get device indices
################################################################################

get_screen_device_indices() {
	indices="$(get_screen_device_names | $GREP -oE '^\[[0-9]\]' | $SED 's/\[//g' | $SED 's/\]//g')"
	echo "$indices"
}
get_audio_device_indices() {
	indices="$(get_audio_device_names | $GREP -oE '^\[[0-9]\]' | $SED 's/\[//g' | $SED 's/\]//g')"
	echo "$indices"
}
get_camera_device_indices() {
	indices="$(get_camera_device_names | $GREP -oE '^\[[0-9]\]' | $SED 's/\[//g' | $SED 's/\]//g')"
	echo "$indices"
}



################################################################################
# Count devices
################################################################################

count_screen_devices() {
	total="$(get_screen_device_names | $GREP -c '')"
	echo "$total"
}
count_audio_devices() {
	total="$(get_audio_device_names | $GREP -c '')"
	echo "$total"
}
count_camera_devices() {
	total="$(get_camera_device_names | $GREP -c '')"
	echo "$total"
}



################################################################################
# Check if device indices exist
################################################################################

#
# Check if screen device exists for given index
#
# @param	integer		Screen device index
# @return	integer		Return code (0: OK | 1: ERR)
screen_device_exists() {
	index=$1
	indices="$(get_screen_device_indices)"
	[[ $indices =~ $index ]] && return 0 || return 1
}

#
# Check if audio device exists for given index
#
# @param	integer		Screen device index
# @return	integer		Return code (0: OK | 1: ERR)
audio_device_exists() {
	index=$1
	indices="$(get_audio_device_indices)"
	[[ $indices =~ $index ]] && return 0 || return 1
}

#
# Check if camera device exists for given index
#
# @param	integer		Screen device index
# @return	integer		Return code (0: OK | 1: ERR)
camera_device_exists() {
	index=$1
	indices="$(get_audio_device_indices)"
	[[ $indices =~ $index ]] && return 0 || return 1
}



################################################################################
# Interactively choose devices
################################################################################

#
# Interactively (via 'read') choose screen device (monitor)
# Note: Using 'return' instead of echo for chosen device,
#       as we need to output success/failer info to the user via 'echo'
#
# @return	integer		Screen device index
choose_screen_device() {
	indices="$(get_screen_device_indices)"

	# List available devices
	printf "$(tput setaf 2)Available devices:$(tput sgr0)\n%s\n" "$(get_screen_device_names)"

	# Ask for device number
	while true; do
		read -r -p "$(tput setaf 2)Enter device number:$(tput sgr0) " dn < /dev/tty
		[ ${#dn} -gt 0 ] && [[ $indices =~ $dn ]] && break || echo 'Wrong device number'
	done
	return "$dn"
}

#
# Interactively (via 'read') choose audio device (microphone)
# Note: Using 'return' instead of echo for chosen device,
#       as we need to output success/failer info to the user via 'echo'
#
# @return	integer		Audio device index
choose_audio_device() {
	indices="$(get_audio_device_indices)"

	# List available devices
	printf "$(tput setaf 2)Available devices:$(tput sgr0)\n%s\n" "$(get_audio_device_names)"

	# Ask for device number
	while true; do
		read -r -p "$(tput setaf 2)Enter device number:$(tput sgr0) " dn < /dev/tty
		[ ${#dn} -gt 0 ] && [[ $indices =~ $dn ]] && break || echo 'Wrong device number'
	done
	return "$dn"
}

#
# Interactively (via 'read') choose camera device
# Note: Using 'return' instead of echo for chosen device,
#       as we need to output success/failer info to the user via 'echo'
#
# @return	integer		Camera device index
choose_camera_device() {
	indices="$(get_camera_device_indices)"

	# List available devices
	printf "$(tput setaf 2)Available devices:$(tput sgr0)\n%s\n" "$(get_camera_device_names)"

	# Ask for device number
	while true; do
		read -r -p "$(tput setaf 2)Enter device number:$(tput sgr0) " dn < /dev/tty
		[ ${#dn} -gt 0 ] && [[ $indices =~ $dn ]] && break || echo 'Wrong device number'
	done
	return "$dn"
}



################################################################################
# Get device properties
################################################################################

#
# Get resolution of chosen screen (monitor)
#
# @param	integer		Screen device index
get_screen_resolution() {
	screen_device_index=$1

	if [ "$(uname)" = "Darwin" ]; then
		resolution="$(get_screen_device_names | $GREP "\[${screen_device_index}\]" | $GREP -oE '[0-9]*\sx\s[0-9]*' | $SED 's/\s//g')"
	elif [ "$(uname)" = "Linux" ]; then
		# ShellCheck does not recognize awk, as we are using it in a variable
		# shellcheck disable=SC2016
		resolution="$(get_screen_device_names | $GREP "\[${screen_device_index}\]" | $GREP -oE '[0-9]*x[0-9]*\spixels' | $AWK '{print $1}')"
	fi

	# Format: [0-9].*x[0-9].* (e.g.: 640x480)
	echo "${resolution}"
}



#
# Get all resolutions/framerates of a given camera
# Output:   WIDTHxHEIGHT@FRAMES
# Example: "1280x720@30 1280x720@25 640x480@30 640x480@10""
#
get_camera_resolutions() {

	# Linux (v4l): Get all camera resolutions

	echo
	# cat v4l.txt | grep -oE '[0-9]+x[0-9]+|[0-9\.]+\sfps' | $SED 's/\sfps//g' | $AWK '{ if($0 ~ /\./) sub("\\.*0+$","");print }' | $AWK '/[0-9]+x[0-9]+/{if (x)print x;x="";}{x=(!x)?$0:x","$0;}END{print x;}' | $SED 's/,/ @ /' | sort -nr | sort -u

}

#
# Get first available resolution of chosen camera
#
# @param	integer		Camera device index
get_default_camera_resolution() {
	camera_device_index=$1

	if [ "$(uname)" = "Darwin" ]; then
		resolution="$(get_camera_device_names | $GREP "\[${camera_device_index}\]" | $GREP -oE '[0-9]+x[0-9]+' | head -n1)"
	# TODO: Add Linux support
	elif [ "$(uname)" = "Linux" ]; then
		resolution=""
	fi
	echo "${resolution}"
}

#
# Get first available framerate of chosen camera for chosen resolution
#
# @param	integer		Camera device index
# @param	string		Camera resolution
get_camera_framerate() {
	camera_device_index="${1}"
	camera_resolution="${2}"

	if [ "$(uname)" = "Darwin" ]; then
		framerate="$(get_camera_device_names | $GREP "\[${camera_device_index}\]" | $GREP -oE "${camera_resolution}@[0-9]+(\.)*[0-9]*" | $SED "s/${camera_resolution}@//")"
	# TODO: Add Linux support
	elif [ "$(uname)" = "Linux" ]; then
		framerate=""
	fi
	echo "${framerate}"
}


################################################################################
# MAIN ENTRY POINT
################################################################################

########################################
# 1.) Default options
########################################

#### Input options
#### ------------------------------

# Enable screen recording by default
screen=yes
sargs=""

camera=no
cargs=""

audio=no
aargs="-ac 2"


#### Output options
#### ------------------------------

# Set default video container extension
ext="mkv"

# Audio codec
audio_codec="libfaac"
#audio_codec="pcm_s16le"


# Video codec
video_codec="libx264"

# Custom ffmpeg arguments
oargs="-crf 0 -preset ultrafast"
#args="-qp 0 -preset ultrafast"


########################################
# 2.) Evaluate cmd arguments
########################################

while [ $# -gt 0  ]; do
	case "$1" in

		#### ---- Screen options ----

		# Screen input device
		-s | -s[0-9]*)
			screen=yes
			screen_num="$(echo "$1" | $SED 's/^..//g')"
			if [ ${#screen_num} -gt 0 ]; then
				if ! isint "${screen_num}" > /dev/null 2>&1; then
					echo "Invalid screen number for -s"
					exit -1
				fi
			fi
			;;
		# Screen args
		--sargs=*)
			sargs="$(echo "$1" | $SED 's/^--sargs=//g')"
			;;


		#### ---- Audio options ----

		# Audio recording
		-a | -a[0-9]*)
			audio=yes
			audio_num="$(echo "$1" | $SED 's/^..//g')"
			if [ ${#audio_num} -gt 0 ]; then
				if ! isint "${audio_num}" > /dev/null 2>&1; then
					echo "Invalid audio number for -a"
					exit -1
				fi
			fi
			;;
		# Audio args
		--aargs=*)
			sargs="$(echo "$1" | $SED 's/^--aargs=//g')"
			;;


		#### ---- Camera options ----

		# Camera input device
		-c | -c[0-9]*)
			camera=yes
			camera_num="$(echo "$1" | $SED 's/^..//g')"
			if [ ${#camera_num} -gt 0 ]; then
				if ! isint "${camera_num}" > /dev/null 2>&1; then
					echo "Invalid camera number for -c"
					exit -1
				fi
			fi
			;;
		# Camera args
		--cargs=*)
			cargs="$(echo "$1" | $SED 's/^--cargs=//g')"
			;;



		#### ---- Output options ----
		-e[a-z]*)
			ext="$(echo "$1" | $SED 's/^..//g')"
			;;

		--oargs=*)
			oargs="$(echo "$1" | $SED 's/^--oargs=//g')"
			;;


		#### ---- Misc options ----

		--dry)
			l_dry=yes
			;;
		--list)
			l_list=yes
			;;
		--slist)
			l_slist=yes
			;;
		--alist)
			l_alist=yes
			;;
		--clist)
			l_clist=yes
			;;
		--help)
			l_help=yes
			;;
		--version)
			l_version=yes
			;;
		--test)
			l_test=yes
			;;
		*)
			echo "Invalid argument: '${1}'"
			echo "Type '${0} --help' for available options."
			exit 1
			;;
	esac
	shift
done



########################################
# 3.) Help/Version/Test
########################################
if [ "${l_help}" = "yes" ]; then
	usage
	exit 0
fi
if [ "${l_version}" = "yes" ]; then
	version
	exit 0
fi
if [ "${l_test}" = "yes" ]; then
	if ! check_requirements "verbose"; then
		exit -1
	else
		exit 0
	fi
fi


########################################
# 4.) Check requirements
########################################

if ! check_requirements; then
	exit -1
fi


########################################
# 5.) List options
########################################

if [ "${l_list}" = "yes" ]; then
	echo "Available screen recording devices (monitors):"
	echo
	get_screen_device_names "${l_dry}"
	echo
	echo

	echo "Available audio recording devices (monitors):"
	echo
	get_audio_device_names "${l_dry}"
	echo
	echo

	echo "Available camera recording devices:"
	echo
	get_camera_device_names "${l_dry}"
	exit 0
fi

if [ "${l_slist}" = "yes" ]; then
	echo "Available screen recording devices (monitors):"
	echo
	get_screen_device_names "${l_dry}"
	exit 0
fi
if [ "${l_alist}" = "yes" ]; then
	echo "Available audio recording devices (microphones):"
	echo
	get_audio_device_names "${l_dry}"
	exit 0
fi
if [ "${l_clist}" = "yes" ]; then
	echo "Available camera recording devices:"
	echo
	get_camera_device_names "${l_dry}"
	exit 0
fi



########################################
# 6.) Build ffmpeg options
########################################

# Does the user want screen recording?
if [ ! -z "${screen+x}" ] && [ "${screen}" = "yes" ]; then

	# If screen device was set via argument list, validate it
	if [ ${#screen_num} -gt 0 ]; then
		if ! screen_device_exists "$screen_num"; then
			echo "Screen recording device: '${screen_num}' does not exist."
			exit -1
		fi
		screen_device="$screen_num"

	# If screen device was not set via argument list, choose one
	else
		# Use default screen if only one screen exists
		if [ "$(count_screen_devices)" = "1" ]; then
			screen_device=$(get_screen_device_indices)
		else
			choose_screen_device
			screen_device=$?
		fi
	fi
fi

# Does the user want audio recording?
if [ ! -z "${audio+x}" ] && [ "${audio}" = "yes" ]; then

	# If screen device was set via argument list, validate it
	if [ ${#audio_num} -gt 0 ]; then
		if ! audio_device_exists "$audio_num"; then
			echo "Audio recording device: '${audio_num}' does not exist."
			exit -1
		fi
		audio_device="$audio_num"

	# If audio device was not set via argument list, choose one
	else
		# Use default audio if only one microphone exists
		if [ "$(count_audio_devices)" = "1" ]; then
			audio_device=$(get_audio_device_indices)
		else
			choose_audio_device
			audio_device=$?
		fi
	fi
fi

# Does the user want camera recording?
if [ ! -z "${camera+x}" ] && [ "${camera}" = "yes" ]; then

	# If camera device was set via argument list, validate it
	if [ ${#camera_num} -gt 0 ]; then
		if ! camera_device_exists "$camera_num"; then
			echo "Camera recording device: '${camera_num}' does not exist."
			exit -1
		fi
		camera_device="$camera_num"

	# If camera device was not set via argument list, choose one
	else
		# Use default camera if only one microphone exists
		if [ "$(count_camera_devices)" = "1" ]; then
			camera_device=$(get_camera_device_indices)
		else
			choose_camera_device
			camera_device=$?
		fi
	fi
fi




########################################
# 7. Build os-specific ffmpeg cmd
########################################


# Get screen resolution of selected monitor
screen_resolution="$(get_screen_resolution "${screen_device}")"


# Get camera resolution/framerate of selected camera
# TODO: Currently only works for OSX
if [ ! -z "${camera+x}" ] && [ "${camera}" = "yes" ]; then
	camera_resolution="$(get_default_camera_resolution "${camera_device}")"
	camera_framerate="$(get_camera_framerate "${camera_device}" "${camera_resolution}")"
fi



if [ "$(uname)" = "Darwin" ]; then

	FF_INPUT_FRAMEWORK_SCREEN="avfoundation"
	FF_INPUT_FRAMEWORK_SOUND="avfoundation"
	FF_INPUT_FRAMEWORK_CAMERA="avfoundation"

	# Get ffmpeg audio command (if audio was selected)
	if [ ! -z "${audio+x}" ] && [ "${audio}" = "yes" ]; then
		audio_device=":${audio_device}"
	fi

	if [ ! -z "${camera+x}" ] && [ "${camera}" = "yes" ]; then
		camera_fix="-video_size ${camera_resolution} -framerate ${camera_framerate}"
	fi


elif [ "$(uname)" = "Linux" ]; then

	FF_INPUT_FRAMEWORK_SCREEN="x11grab"
	FF_INPUT_FRAMEWORK_SOUND="alsa"		# TODO: what about pulse??
	FF_INPUT_FRAMEWORK_CAMERA="v4l2"

	# Get ffmpeg audio command (if audio was selected)
	if [ ! -z "${audio+x}" ] && [ "${audio}" = "yes" ]; then
		audio_name="$(get_audio_device_names | $GREP "\[${audio_device}\]")"
		# ShellCheck does not recognize awk, as we are using it in a variable
		# shellcheck disable=SC2016
		audio_card="$(echo "${audio_name}" | $GREP -oE 'card\s[0-9]*' | $AWK '{print $2}')"
		# ShellCheck does not recognize awk, as we are using it in a variable
		# shellcheck disable=SC2016
		audio_device="$(echo "${audio_name}" | $GREP -oE 'device\s[0-9]*' | $AWK '{print $2}')"
		audio_device="hw:${audio_card},${audio_device}"
	fi

	# Get camera device
	if [ ! -z "${camera+x}" ] && [ "${camera}" = "yes" ]; then
		camera_device="$(get_camera_device_names | $GREP "\[${camera_device}\]" | $GREP -oE '/dev/video[0-9]*')"
		camera_fix=""
	fi

	screen_device=":0.0"

fi



FFMPEG="ffmpeg"
FFMPEG="${FFMPEG} -hide_banner -loglevel info"

# Video Options
FFMPEG="${FFMPEG} -thread_queue_size 512"

# If we are able to get the screen resolution, use it
if [ "$screen_resolution" != "" ]; then
	FFMPEG="${FFMPEG} -f ${FF_INPUT_FRAMEWORK_SCREEN} -video_size ${screen_resolution} ${sargs} -i \"${screen_device}\""
else
	FFMPEG="${FFMPEG} -f ${FF_INPUT_FRAMEWORK_SCREEN} ${sargs} -i \"${screen_device}\""
fi

# Camera Options (1/2)
if [ ! -z "${camera+x}" ] && [ "${camera}" = "yes" ]; then
	FFMPEG="${FFMPEG} -thread_queue_size 512"
	FFMPEG="${FFMPEG} -f ${FF_INPUT_FRAMEWORK_CAMERA} ${camera_fix} ${cargs} -i \"${camera_device}\""
fi

# Sound Options
if [ ! -z "${audio+x}" ] && [ "${audio}" = "yes" ]; then
	FFMPEG="${FFMPEG} -thread_queue_size 512"
	FFMPEG="${FFMPEG} -f ${FF_INPUT_FRAMEWORK_SOUND} ${aargs} -i \"${audio_device}\""
	FFMPEG="${FFMPEG} -c:a ${audio_codec}"
fi

FFMPEG="${FFMPEG} -c:v ${video_codec}"
FFMPEG="${FFMPEG} ${oargs}"

# Camera Options (2/2)
if [ ! -z "${camera+x}" ] && [ "${camera}" = "yes" ]; then
	FFMPEG="${FFMPEG} -filter_complex 'overlay=main_w-overlay_w-10:main_h-overlay_h-10'"
fi

FFMPEG="${FFMPEG} -threads 0"
FFMPEG="${FFMPEG} \"${DIR}/${NAME}.${ext}\""


#### RUN
if [ "${l_dry}" = "yes" ]; then
	echo "$FFMPEG"
else
	echo "$FFMPEG"
	eval "$FFMPEG"
fi

